function t(t,e){const n=Object.create(null),r=t.split(",");for(let t=0;t<r.length;t++)n[r[t]]=!0;return e?t=>!!n[t.toLowerCase()]:t=>!!n[t]}const e={},n=()=>{},r=Object.prototype.hasOwnProperty,o=(t,e)=>r.call(t,e),c=Array.isArray,s=t=>"symbol"==typeof t,u=t=>null!==t&&"object"==typeof t,i=Object.prototype.toString,l=t=>(t=>i.call(t))(t).slice(8,-1),a=(t,e)=>t!==e&&(t==t||e==e),f=new WeakMap,d=[];let h;const p=Symbol(""),g=Symbol("");function v(t,n=e){(function(t){return t&&!0===t._isEffect})(t)&&(t=t.raw);const r=function(t,e){const n=function(...r){if(!n.active)return e.scheduler?void 0:t(...r);if(!d.includes(n)){S(n);try{return M(),d.push(n),h=n,t(...r)}finally{d.pop(),k(),h=d[d.length-1]}}};return n.id=w++,n._isEffect=!0,n.active=!0,n.raw=t,n.deps=[],n.options=e,n}(t,n);return n.lazy||r(),r}function y(t){t.active&&(S(t),t.options.onStop&&t.options.onStop(),t.active=!1)}let w=0;function S(t){const{deps:e}=t;if(e.length){for(let n=0;n<e.length;n++)e[n].delete(t);e.length=0}}let b=!0;const R=[];function m(){R.push(b),b=!1}function M(){R.push(b),b=!0}function k(){const t=R.pop();b=void 0===t||t}function E(t,e,n){if(!b||void 0===h)return;let r=f.get(t);void 0===r&&f.set(t,r=new Map);let o=r.get(n);void 0===o&&r.set(n,o=new Set),o.has(h)||(o.add(h),h.deps.push(o))}function O(t,e,n,r,o,s){const u=f.get(t);if(void 0===u)return;const i=new Set,l=new Set,a=t=>{void 0!==t&&t.forEach(t=>{t===h&&b||(t.options.computed?l.add(t):i.add(t))})};if("clear"===e)u.forEach(a);else if("length"===n&&c(t))u.forEach((t,e)=>{("length"===e||e>=r)&&a(t)});else{void 0!==n&&a(u.get(n));const r="add"===e||"delete"===e&&!c(t);(r||"set"===e&&t instanceof Map)&&a(u.get(c(t)?"length":p)),r&&t instanceof Map&&a(u.get(g))}const d=t=>{void 0!==t.options.scheduler?t.options.scheduler(t):t()};l.forEach(d),i.forEach(d)}const W=new Set(Object.getOwnPropertyNames(Symbol).map(t=>Symbol[t]).filter(s)),_=A(),j=A(!1,!0),z=A(!0),P=A(!0,!0),x={};function A(t=!1,e=!1){return function(n,r,i){const l=c(n);if(l&&o(x,r))return Reflect.get(x,r,i);const a=Reflect.get(n,r,i);return s(r)&&W.has(r)?a:e?(!t&&E(n,0,r),a):Rt(a)?l?(!t&&E(n,0,r),a):a.value:(!t&&E(n,0,r),u(a)?t?dt(a):at(a):a)}}["includes","indexOf","lastIndexOf"].forEach(t=>{x[t]=function(...e){const n=wt(this);for(let t=0,e=this.length;t<e;t++)E(n,0,t+"");const r=n[t](...e);return-1===r||!1===r?n[t](...e.map(wt)):r}});const K=V(),N=V(!0);function V(t=!1){return function(e,n,r,s){const u=e[n];if(!t&&(r=wt(r),!c(e)&&Rt(u)&&!Rt(r)))return u.value=r,!0;const i=o(e,n),l=Reflect.set(e,n,r,s);return e===wt(s)&&(i?a(r,u)&&O(e,"set",n,r):O(e,"add",n,r)),l}}function C(t,e){const n=Reflect.has(t,e);return E(t,0,e),n}function F(t){return E(t,0,p),Reflect.ownKeys(t)}const I={get:_,set:K,deleteProperty:function(t,e){const n=o(t,e),r=Reflect.deleteProperty(t,e);return r&&n&&O(t,"delete",e,void 0),r},has:C,ownKeys:F},L={get:z,has:C,ownKeys:F,set:(t,e)=>!0,deleteProperty:(t,e)=>!0},q={...I,get:j,set:N},B={...L,get:P},D=t=>u(t)?at(t):t,G=t=>u(t)?dt(t):t,H=t=>Reflect.getPrototypeOf(t);function J(t,e,n){t=wt(t);const r=wt(e);e!==r&&E(t,0,e),E(t,0,r);const{has:o,get:c}=H(t);return o.call(t,e)?n(c.call(t,e)):o.call(t,r)?n(c.call(t,r)):void 0}function Q(t){const e=wt(this),n=wt(t);t!==n&&E(e,0,t),E(e,0,n);const r=H(e).has;return r.call(e,t)||r.call(e,n)}function T(t){return E(t=wt(t),0,p),Reflect.get(H(t),"size",t)}function U(t){return function(e,n){const r=this,o=wt(r),c=t?G:D;return!t&&E(o,0,p),H(o).forEach.call(o,(function(t,n){return e.call(r,c(t),c(n),r)}),n)}}function X(t,e){return function(...n){const r=wt(this),o=r instanceof Map,c="entries"===t||t===Symbol.iterator&&o,s="keys"===t&&o,u=H(r)[t].apply(r,n),i=e?G:D;return!e&&E(r,0,s?g:p),{next(){const{value:t,done:e}=u.next();return e?{value:t,done:e}:{value:c?[i(t[0]),i(t[1])]:i(t),done:e}},[Symbol.iterator](){return this}}}}function Y(t){return function(...e){return"delete"!==t&&this}}const Z={get(t){return J(this,t,D)},get size(){return T(this)},has:Q,add:function(t){t=wt(t);const e=wt(this),n=H(e),r=n.has.call(e,t),o=n.add.call(e,t);return r||O(e,"add",t,t),o},set:function(t,e){e=wt(e);const n=wt(this),{has:r,get:o,set:c}=H(n);let s=r.call(n,t);s||(t=wt(t),s=r.call(n,t));const u=o.call(n,t),i=c.call(n,t,e);return s?a(e,u)&&O(n,"set",t,e):O(n,"add",t,e),i},delete:function(t){const e=wt(this),{has:n,get:r,delete:o}=H(e);let c=n.call(e,t);c||(t=wt(t),c=n.call(e,t)),r&&r.call(e,t);const s=o.call(e,t);return c&&O(e,"delete",t,void 0),s},clear:function(){const t=wt(this),e=0!==t.size,n=H(t).clear.call(t);return e&&O(t,"clear",void 0,void 0),n},forEach:U(!1)},$={get(t){return J(this,t,G)},get size(){return T(this)},has:Q,add:Y("add"),set:Y("set"),delete:Y("delete"),clear:Y("clear"),forEach:U(!0)};function tt(t){return(e,n,r)=>Reflect.get(o(t,n)&&n in e?t:e,n,r)}["keys","values","entries",Symbol.iterator].forEach(t=>{Z[t]=X(t,!1),$[t]=X(t,!0)});const et={get:tt(Z)},nt={get:tt($)},rt=new WeakMap,ot=new WeakMap,ct=new WeakMap,st=new WeakMap,ut=new WeakSet,it=new Set([Set,Map,WeakMap,WeakSet]),lt=t("Object,Array,Map,Set,WeakMap,WeakSet");function at(t){return st.has(t)?t:pt(t,rt,ot,I,et)}function ft(t){return pt(t,rt,ot,q,et)}function dt(t){return pt(t,ct,st,L,nt)}function ht(t){return pt(t,ct,st,B,nt)}function pt(t,e,n,r,o){if(!u(t))return t;let c=e.get(t);if(void 0!==c)return c;if(n.has(t))return t;if((s=t)._isVue||s._isVNode||!lt(l(s))||ut.has(s)||Object.isFrozen(s))return t;var s;const i=it.has(t.constructor)?o:r;return c=new Proxy(t,i),e.set(t,c),n.set(c,t),c}function gt(t){return t=st.get(t)||t,ot.has(t)}function vt(t){return st.has(t)}function yt(t){return st.has(t)||ot.has(t)}function wt(t){return t=st.get(t)||t,ot.get(t)||t}function St(t){return ut.add(t),t}const bt=t=>u(t)?at(t):t;function Rt(t){return!!t&&!0===t._isRef}function mt(t){return kt(t)}function Mt(t){return kt(t,!0)}function kt(t,e=!1){if(Rt(t))return t;e||(t=bt(t));const n={_isRef:!0,get value(){return E(n,0,"value"),t},set value(r){t=e?r:bt(r),O(n,"set","value",void 0)}};return n}function Et(t){return Rt(t)?t.value:t}function Ot(t){const{get:e,set:n}=t(()=>E(r,0,"value"),()=>O(r,"set","value")),r={_isRef:!0,get value(){return e()},set value(t){n(t)}};return r}function Wt(t){const e={};for(const n in t)e[n]=_t(t,n);return e}function _t(t,e){return{_isRef:!0,get value(){return t[e]},set value(n){t[e]=n}}}function jt(t){let e,r;"function"==typeof t?(e=t,r=n):(e=t.get,r=t.set);let o,c,s=!0;const u=v(e,{lazy:!0,computed:!0,scheduler:()=>{s||(s=!0,O(c,"set","value"))}});return c={_isRef:!0,effect:u,get value(){return s&&(o=u(),s=!1),E(c,0,"value"),o},set value(t){r(t)}},c}export{p as ITERATE_KEY,jt as computed,Ot as customRef,v as effect,M as enableTracking,yt as isProxy,gt as isReactive,vt as isReadonly,Rt as isRef,St as markRaw,m as pauseTracking,at as reactive,dt as readonly,mt as ref,k as resetTracking,ft as shallowReactive,ht as shallowReadonly,Mt as shallowRef,y as stop,wt as toRaw,_t as toRef,Wt as toRefs,E as track,O as trigger,Et as unref};
